<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Neon Genesis - Gemini's Art</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui {
            position: absolute; bottom: 20px; left: 20px;
            color: #0ff; font-family: monospace; font-size: 14px;
            pointer-events: none; user-select: none;
            text-shadow: 0 0 5px #0ff;
        }
        .k { border: 1px solid #0ff; padding: 2px 6px; border-radius: 4px; }
    </style>
</head>
<body>
    <div id="ui">
        DIMENSION: <span id="d-val">1</span><br><br>
        <span class="k">↑</span> <span class="k">↓</span> : SHIFT REALITY<br>
        MOUSE : WARP FIELD<br>
        CLICK : IMPLODE
    </div>
    <canvas id="c"></canvas>

    <script>
    // --- SHADER 1: PHYSICS (Compute - Read/Write) ---
    const SHADER_COMPUTE = `
        struct Uniforms {
            mouse: vec2f,
            time: f32,
            click: f32,
            aspect: f32,
            dim: f32,
        };
        struct Particle {
            pos: vec4f, 
            vel: vec4f,
        };
        @group(0) @binding(0) var<uniform> u: Uniforms;
        @group(0) @binding(1) var<storage, read_write> p: array<Particle>;

        @compute @workgroup_size(64)
        fn main(@builtin(global_invocation_id) id: vec3u) {
            let i = id.x;
            if (i >= arrayLength(&p)) { return; }
            
            var part = p[i];
            let t = u.time;

            // --- DIMENSION MATH ---
            var force = vec3f(0.0);
            
            // Dim 1: The Swarm
            if (u.dim < 0.5) {
                force = vec3f(sin(part.pos.y*0.2 + t), cos(part.pos.x*0.2 - t), sin(part.pos.z*0.1));
            } 
            // Dim 2: The Spiral
            else if (u.dim < 1.5) {
                let r = length(part.pos.xy);
                let a = atan2(part.pos.y, part.pos.x);
                force = vec3f(cos(a+t + part.pos.z*0.1), sin(a+t + part.pos.z*0.1), 0.0);
                force *= (r + 1.0) * 0.1;
            } 
            // Dim 3: The Rain
            else {
                force = vec3f(0.0, -2.0, 0.0);
                if (part.pos.y < -30.0) { 
                    part.pos.y = 30.0; 
                    part.vel = vec4f(0.0); 
                }
            }

            // Mouse Interaction
            let m = vec3f(u.mouse.x * 40.0 * u.aspect, u.mouse.y * 40.0, 0.0);
            let d = m - part.pos.xyz;
            let dist = length(d);
            let dir = normalize(d);
            
            // Integrate
            part.vel += vec4f(force * 0.01, 0.0);
            part.vel += vec4f(dir * (10.0 / (dist+1.0)) * 0.01, 0.0); // Attract
            part.vel -= vec4f(dir * (u.click * 100.0 / (dist+0.1)) * 0.1, 0.0); // Repel
            part.vel *= 0.96; // Friction
            
            part.pos += part.vel;

            // Bounds
            let b = 50.0;
            if (part.pos.x > b) { part.pos.x = -b; } if (part.pos.x < -b) { part.pos.x = b; }
            if (u.dim < 1.5) {
                if (part.pos.y > b) { part.pos.y = -b; } if (part.pos.y < -b) { part.pos.y = b; }
            }
            if (part.pos.z > 20.0) { part.pos.z = -50.0; } if (part.pos.z < -50.0) { part.pos.z = 20.0; }

            p[i] = part;
        }
    `;

    // --- SHADER 2: VISUALS (Vertex - Read Only) ---
    const SHADER_RENDER = `
        struct Uniforms {
            mouse: vec2f,
            time: f32,
            click: f32,
            aspect: f32,
            dim: f32,
        };
        struct Particle {
            pos: vec4f,
            vel: vec4f,
        };
        @group(0) @binding(0) var<uniform> u: Uniforms;
        @group(0) @binding(1) var<storage, read> p: array<Particle>; // READ ONLY!

        struct VSOut {
            @builtin(position) pos: vec4f,
            @location(0) color: vec4f,
        };

        @vertex
        fn vs(@builtin(vertex_index) vIdx: u32, @builtin(instance_index) iIdx: u32) -> VSOut {
            let part = p[iIdx];
            
            // Camera
            let z = 60.0 - part.pos.z;
            let scale = 1.0 / max(z, 0.1);
            let size = 120.0 * scale;

            // Triangle
            var c = vec2f(0.0, -0.5);
            if (vIdx == 1u) { c = vec2f(0.5, 0.5); }
            if (vIdx == 2u) { c = vec2f(-0.5, 0.5); }

            let sx = (part.pos.x * scale + c.x * size * 0.015) / u.aspect;
            let sy = part.pos.y * scale + c.y * size * 0.015;

            var out: VSOut;
            out.pos = vec4f(sx, sy, 0.0, 1.0);
            
            // Color Logic
            let spd = length(part.vel.xyz);
            var col = vec3f(0.0);

            if (u.dim < 0.5) { col = vec3f(0.0, 1.0, 1.0); } // Cyan
            else if (u.dim < 1.5) { col = vec3f(1.0, 0.2, 0.5); } // Hot Pink
            else { col = vec3f(0.2, 1.0, 0.2); } // Matrix Green

            out.color = vec4f(col * (0.5 + spd * 2.0), 1.0);
            return out;
        }

        @fragment
        fn fs(@location(0) color: vec4f) -> @location(0) vec4f {
            return color;
        }
    `;

    async function init() {
        const cvs = document.getElementById('c');
        const dVal = document.getElementById('d-val');
        
        if (!navigator.gpu) return alert("WebGPU not enabled in browser.");
        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) return alert("No GPU adapter found.");
        const device = await adapter.requestDevice();
        
        const ctx = cvs.getContext('webgpu');
        const fmt = navigator.gpu.getPreferredCanvasFormat();
        
        // SETUP CANVAS (Opaque)
        ctx.configure({ device, format: fmt, alphaMode: 'opaque' });

        // BUFFERS
        const COUNT = 40000;
        const pData = new Float32Array(COUNT * 8); // 8 floats (pos4 + vel4)
        for(let i=0; i<COUNT*8; i++) pData[i] = (Math.random()-0.5)*50;

        const bufP = device.createBuffer({
            size: pData.byteLength,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            mappedAtCreation: true
        });
        new Float32Array(bufP.getMappedRange()).set(pData);
        bufP.unmap();

        // UNIFORM BUFFER (Aligned to 32 bytes)
        const bufU = device.createBuffer({
            size: 32, 
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        });

        // PIPELINE 1: COMPUTE
        const modC = device.createShaderModule({ code: SHADER_COMPUTE });
        const pipeC = device.createComputePipeline({
            layout: 'auto',
            compute: { module: modC, entryPoint: 'main' }
        });

        // PIPELINE 2: RENDER
        const modR = device.createShaderModule({ code: SHADER_RENDER });
        const pipeR = device.createRenderPipeline({
            layout: 'auto',
            vertex: { module: modR, entryPoint: 'vs' },
            fragment: { module: modR, entryPoint: 'fs', targets: [{ format: fmt }] },
            primitive: { topology: 'triangle-list' }
        });

        // BIND GROUPS (The Fix: Separate Bind Groups for separate Pipelines)
        const bgC = device.createBindGroup({
            layout: pipeC.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: bufU } },
                { binding: 1, resource: { buffer: bufP } }
            ]
        });

        const bgR = device.createBindGroup({
            layout: pipeR.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: bufU } },
                { binding: 1, resource: { buffer: bufP } }
            ]
        });

        // STATE & INPUT
        let state = { x: 0, y: 0, c: 0, dim: 0 };
        window.onmousemove = e => {
            state.x = (e.clientX / window.innerWidth) * 2 - 1;
            state.y = -(e.clientY / window.innerHeight) * 2 + 1;
        };
        window.onmousedown = () => state.c = 1;
        window.onmouseup = () => state.c = 0;
        window.onkeydown = e => {
            if(e.key === "ArrowUp") state.dim = (state.dim + 1) % 3;
            if(e.key === "ArrowDown") state.dim = (state.dim - 1 + 3) % 3;
            dVal.innerText = state.dim + 1;
        };

        const resize = () => { cvs.width = window.innerWidth; cvs.height = window.innerHeight; };
        window.onresize = resize;
        resize();

        // LOOP
        const start = performance.now();
        function frame() {
            const t = (performance.now() - start) * 0.001;
            
            // Update Uniforms
            device.queue.writeBuffer(bufU, 0, new Float32Array([
                state.x, state.y, t, state.c, cvs.width/cvs.height, state.dim, 0, 0
            ]));

            const enc = device.createCommandEncoder();

            // Compute Pass
            const passC = enc.beginComputePass();
            passC.setPipeline(pipeC);
            passC.setBindGroup(0, bgC);
            passC.dispatchWorkgroups(Math.ceil(COUNT / 64));
            passC.end();

            // Render Pass
            const passR = enc.beginRenderPass({
                colorAttachments: [{
                    view: ctx.getCurrentTexture().createView(),
                    clearValue: { r: 0, g: 0, b: 0, a: 1 },
                    loadOp: 'clear', storeOp: 'store'
                }]
            });
            passR.setPipeline(pipeR);
            passR.setBindGroup(0, bgR);
            passR.draw(3, COUNT);
            passR.end();

            device.queue.submit([enc.finish()]);
            requestAnimationFrame(frame);
        }
        requestAnimationFrame(frame);
    }
    init();
    </script>
</body>
</html>