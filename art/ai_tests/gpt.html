<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Parallax Without Permission - GPT's Art</title>
<style>
html,body{margin:0;height:100%;background:#000;overflow:hidden}
canvas{width:100vw;height:100vh;display:block}
#hint{position:fixed;bottom:10px;left:10px;color:#888;font-family:sans-serif;font-size:12px;user-select:none}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hint">Drag mouse = parallax â€¢ Up/Down = depth layers</div>
<script type="module">
const canvas = document.getElementById('c');
if (!navigator.gpu) throw new Error('No WebGPU');

const adapter = await navigator.gpu.requestAdapter({ powerPreference:'low-power' });
const device = await adapter.requestDevice();
const context = canvas.getContext('webgpu');
const format = navigator.gpu.getPreferredCanvasFormat();

let w=innerWidth, h=innerHeight;
function resize(){ canvas.width=w; canvas.height=h; context.configure({device,format,alphaMode:'opaque'}); }
addEventListener('resize',()=>{w=innerWidth;h=innerHeight;resize();});
resize();

let mx=0,my=0,layers=4;
canvas.addEventListener('pointermove',e=>{ if(e.buttons){ mx+=(e.movementX)/w; my+=(e.movementY)/h; }});
addEventListener('keydown',e=>{ if(e.key==='ArrowUp') layers=Math.min(10,layers+1); if(e.key==='ArrowDown') layers=Math.max(1,layers-1); });

const uniform = device.createBuffer({ size:16, usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST });

const shader = device.createShaderModule({code:`
@vertex fn vs(@builtin(vertex_index)i:u32)->@builtin(position) vec4<f32>{
  var p=array<vec2<f32>,3>(vec2(-1,-1),vec2(3,-1),vec2(-1,3));
  return vec4(p[i],0,1);
}
@group(0) @binding(0) var<uniform> u:vec4<f32>; // mx my layers time
@fragment fn fs(@builtin(position) p:vec4<f32>)->@location(0) vec4<f32>{
  let uv=(p.xy/vec2<f32>(f32(${w}),f32(${h})))*2.0-1.0;
  var col=vec3<f32>(0.0);
  for(var i=0;i<10;i++){
    if(f32(i)>=u.z){ break; }
    let d=f32(i)/u.z;
    let shift=uv + vec2<f32>(u.x,u.y)*d*1.5;
    let r=length(shift);
    let c=0.5+0.5*cos(8.0*r - u.w*2.0 + d*4.0);
    col += vec3<f32>(c*(1.0-d), c*(0.5+d), c);
  }
  col/=u.z;
  return vec4(col,1.0);
}`});

const pipeline = device.createRenderPipeline({
  layout:'auto',
  vertex:{ module:shader, entryPoint:'vs' },
  fragment:{ module:shader, entryPoint:'fs', targets:[{format}] },
  primitive:{ topology:'triangle-list' }
});

const bindGroup = device.createBindGroup({ layout:pipeline.getBindGroupLayout(0), entries:[{ binding:0, resource:{ buffer:uniform } }] });

let t0=performance.now();
function frame(){
  const t=(performance.now()-t0)*0.001;
  device.queue.writeBuffer(uniform,0,new Float32Array([mx,my,layers,t]));
  const enc=device.createCommandEncoder();
  const pass=enc.beginRenderPass({ colorAttachments:[{ view:context.getCurrentTexture().createView(), loadOp:'clear', storeOp:'store', clearValue:{r:0,g:0,b:0,a:1} }] });
  pass.setPipeline(pipeline);
  pass.setBindGroup(0,bindGroup);
  pass.draw(3);
  pass.end();
  device.queue.submit([enc.finish()]);
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</script>
</body>
</html>
