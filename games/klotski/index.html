<!DOCTYPE html>
<html>
<head>
  <title>Klotski Puzzle</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      font-family: 'Segoe UI', sans-serif;
    }
    #game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }
    #stats {
      display: flex;
      gap: 30px;
      color: #fff;
      font-size: 18px;
    }
    .stat { 
      background: rgba(255,255,255,0.1);
      padding: 8px 20px;
      border-radius: 8px;
    }
    .stat span { font-weight: bold; color: #ffd700; }
    #timer.flashing { animation: flash 0.5s infinite; }
    @keyframes flash {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }
    #reset-btn {
      padding: 10px 25px;
      font-size: 16px;
      background: #e74c3c;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      opacity: 0;
      pointer-events: none;
    }
    #reset-btn.visible { opacity: 1; pointer-events: auto; }
    #reset-btn:hover { background: #c0392b; transform: scale(1.05); }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="stats">
      <div class="stat" id="timer">Time: <span>00:00.000</span></div>
      <div class="stat">Moves: <span id="moves">0</span></div>
    </div>
    <div id="game"></div>
    <button id="reset-btn">Reset</button>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
  <script>
const CELL = 80, COLS = 4, ROWS = 5;
const BOARD_W = COLS * CELL, BOARD_H = ROWS * CELL, PAD = 40;

const initialPieces = [
  { id: 'A', x: 0, y: 0, w: 1, h: 2, type: 'tall' },
  { id: 'B', x: 1, y: 0, w: 2, h: 2, type: 'main' },
  { id: 'C', x: 3, y: 0, w: 1, h: 2, type: 'tall' },
  { id: 'D', x: 1, y: 2, w: 2, h: 1, type: 'wide' },
  { id: 'E', x: 0, y: 3, w: 1, h: 2, type: 'tall' },
  { id: 'F', x: 1, y: 3, w: 1, h: 1, type: 'small' },
  { id: 'G', x: 2, y: 3, w: 1, h: 1, type: 'small' },
  { id: 'H', x: 3, y: 3, w: 1, h: 2, type: 'tall' },
  { id: 'I', x: 1, y: 4, w: 1, h: 1, type: 'small' },
  { id: 'J', x: 2, y: 4, w: 1, h: 1, type: 'small' },
];

const colors = { main: 0xFFD700, tall: 0x3498db, wide: 0x9b59b6, small: 0x2ecc71 };

let app, boardContainer, piecesContainer, confettiContainer;
let pieces = [], moves = 0, timerStart = null, timerInterval = null, gameWon = false, grid = [];

async function init() {
  app = new PIXI.Application({ 
    width: BOARD_W + PAD * 2, 
    height: BOARD_H + PAD * 2 + 40,
    backgroundColor: 0x0f0f23, 
    antialias: true 
  });
  document.getElementById('game').appendChild(app.view);

  boardContainer = new PIXI.Container();
  boardContainer.x = PAD;
  boardContainer.y = PAD;
  app.stage.addChild(boardContainer);
  
  drawBoard();
  
  piecesContainer = new PIXI.Container();
  boardContainer.addChild(piecesContainer);
  
  confettiContainer = new PIXI.Container();
  app.stage.addChild(confettiContainer);
  
  app.stage.eventMode = 'static';
  app.stage.hitArea = app.screen;

  resetGame();
  document.getElementById('reset-btn').addEventListener('click', resetGame);
}

function drawBoard() {
  const bg = new PIXI.Graphics();
  bg.beginFill(0x2d2d44);
  bg.drawRoundedRect(-10, -10, BOARD_W + 20, BOARD_H + 20, 10);
  bg.endFill();
  boardContainer.addChild(bg);

  const gridLines = new PIXI.Graphics();
  gridLines.lineStyle(1, 0x3d3d5c);
  for (let i = 0; i <= COLS; i++) { gridLines.moveTo(i * CELL, 0); gridLines.lineTo(i * CELL, BOARD_H); }
  for (let i = 0; i <= ROWS; i++) { gridLines.moveTo(0, i * CELL); gridLines.lineTo(BOARD_W, i * CELL); }
  boardContainer.addChild(gridLines);

  const walls = new PIXI.Graphics();
  walls.lineStyle(6, 0x8b7355);
  walls.moveTo(0, 0); walls.lineTo(BOARD_W, 0);
  walls.moveTo(0, 0); walls.lineTo(0, BOARD_H);
  walls.moveTo(BOARD_W, 0); walls.lineTo(BOARD_W, BOARD_H);
  walls.moveTo(0, BOARD_H); walls.lineTo(CELL, BOARD_H);
  walls.moveTo(CELL * 3, BOARD_H); walls.lineTo(BOARD_W, BOARD_H);
  boardContainer.addChild(walls);

  const exit = new PIXI.Graphics();
  exit.beginFill(0x27ae60);
  exit.drawRoundedRect(CELL + 5, BOARD_H - 5, CELL * 2 - 10, 15, 3);
  exit.endFill();
  boardContainer.addChild(exit);
  
  const exitText = new PIXI.Text('▼ EXIT ▼', { fontSize: 14, fill: 0x27ae60, fontWeight: 'bold' });
  exitText.x = CELL * 2 - exitText.width / 2;
  exitText.y = BOARD_H + 8;
  boardContainer.addChild(exitText);
}

function createPiece(data) {
  const c = new PIXI.Container();
  c.x = data.x * CELL;
  c.y = data.y * CELL;
  c.pieceData = { ...data };
  c.eventMode = 'static';
  c.cursor = 'grab';

  const w = data.w * CELL - 6, h = data.h * CELL - 6;
  const color = colors[data.type];

  const shadow = new PIXI.Graphics();
  shadow.beginFill(0x000000, 0.3);
  shadow.drawRoundedRect(6, 6, w, h, 8);
  shadow.endFill();
  c.addChild(shadow);

  const body = new PIXI.Graphics();
  body.beginFill(color);
  body.drawRoundedRect(3, 3, w, h, 8);
  body.endFill();
  c.addChild(body);
  c.body = body;

  const hl = new PIXI.Graphics();
  hl.beginFill(0xffffff, 0.25);
  hl.drawRoundedRect(6, 6, w - 6, h / 3, 6);
  hl.endFill();
  c.addChild(hl);

  if (data.type === 'main') {
    const face = new PIXI.Container();
    face.x = w / 2 + 3;
    face.y = h / 2 + 3;
    
    const lEye = new PIXI.Graphics();
    lEye.beginFill(0x000000);
    lEye.drawCircle(-18, -12, 7);
    lEye.endFill();
    face.addChild(lEye);
    
    const rEye = new PIXI.Graphics();
    rEye.beginFill(0x000000);
    rEye.drawCircle(18, -12, 7);
    rEye.endFill();
    face.addChild(rEye);
    
    const mouth = new PIXI.Graphics();
    mouth.lineStyle(4, 0x000000);
    mouth.moveTo(-15, 15);
    mouth.lineTo(15, 15);
    c.mouth = mouth;
    face.addChild(mouth);
    c.face = face;
    c.addChild(face);
  }

  let dragging = false, dragStart = {}, origPos = {};

  c.on('pointerdown', (e) => {
    if (gameWon) return;
    dragging = true;
    c.cursor = 'grabbing';
    dragStart = { x: e.global.x, y: e.global.y };
    origPos = { x: c.x, y: c.y };
    piecesContainer.addChild(c);
  });

  app.stage.on('pointermove', (e) => {
    if (!dragging) return;
    c.x = origPos.x + (e.global.x - dragStart.x);
    c.y = origPos.y + (e.global.y - dragStart.y);
  });

  const endDrag = () => {
    if (!dragging) return;
    dragging = false;
    c.cursor = 'grab';
    
    const newGX = Math.round(c.x / CELL);
    const newGY = Math.round(c.y / CELL);
    const oldGX = origPos.x / CELL;
    const oldGY = origPos.y / CELL;
    
    // Find path from old position to new position
    const path = findPath(c.pieceData, oldGX, oldGY, newGX, newGY);
    
    if (path && path.length > 0) {
      const finalPos = path[path.length - 1];
      c.x = finalPos.x * CELL;
      c.y = finalPos.y * CELL;
      
      // Update grid to final position
      clearFromGrid(c.pieceData, oldGX, oldGY);
      addToGrid(c.pieceData, finalPos.x, finalPos.y);
      c.pieceData.x = finalPos.x;
      c.pieceData.y = finalPos.y;
      
      // Add moves equal to path length
      moves += path.length;
      document.getElementById('moves').textContent = moves;
      document.getElementById('reset-btn').classList.add('visible');
      if (!timerStart) startTimer();
      
      if (c.pieceData.type === 'main' && finalPos.y >= ROWS - 1) {
        winGame(c);
      }
    } else {
      c.x = origPos.x;
      c.y = origPos.y;
    }
  };

  app.stage.on('pointerup', endDrag);
  app.stage.on('pointerupoutside', endDrag);
  return c;
}

// BFS pathfinding - finds shortest path allowing corners
function findPath(piece, startX, startY, endX, endY) {
  if (startX === endX && startY === endY) return null;
  
  // Temporarily remove piece from grid
  clearFromGrid(piece, startX, startY);
  
  const queue = [{ x: startX, y: startY, path: [] }];
  const visited = new Set();
  visited.add(`${startX},${startY}`);
  
  const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
  let result = null;
  
  while (queue.length > 0) {
    const { x: cx, y: cy, path } = queue.shift();
    
    for (const [dx, dy] of directions) {
      const nx = cx + dx, ny = cy + dy;
      const key = `${nx},${ny}`;
      
      if (visited.has(key)) continue;
      if (!isValidPosition(piece, nx, ny)) continue;
      
      const newPath = [...path, { x: nx, y: ny }];
      
      if (nx === endX && ny === endY) {
        result = newPath;
        break;
      }
      
      // Limit search depth to prevent long weird paths (max 10 moves)
      if (newPath.length < 10) {
        visited.add(key);
        queue.push({ x: nx, y: ny, path: newPath });
      }
    }
    
    if (result) break;
  }
  
  // Restore piece to original position
  addToGrid(piece, startX, startY);
  
  return result;
}

function isValidPosition(piece, x, y) {
  if (x < 0 || y < 0 || x + piece.w > COLS) return false;
  
  if (piece.type === 'main') {
    if (x !== 1 && y + piece.h > ROWS) return false;
    if (x === 1 && y + piece.h > ROWS + 1) return false;
  } else {
    if (y + piece.h > ROWS) return false;
  }
  
  for (let px = 0; px < piece.w; px++) {
    for (let py = 0; py < piece.h; py++) {
      const cx = x + px, cy = y + py;
      if (cy < ROWS && grid[cy] && grid[cy][cx]) {
        return false;
      }
    }
  }
  return true;
}

function clearFromGrid(piece, x, y) {
  for (let px = 0; px < piece.w; px++) {
    for (let py = 0; py < piece.h; py++) {
      if (y + py < ROWS) grid[y + py][x + px] = null;
    }
  }
}

function addToGrid(piece, x, y) {
  for (let px = 0; px < piece.w; px++) {
    for (let py = 0; py < piece.h; py++) {
      if (y + py < ROWS) grid[y + py][x + px] = piece.id;
    }
  }
}

function buildGrid() {
  grid = Array(ROWS).fill(null).map(() => Array(COLS).fill(null));
  pieces.forEach(p => {
    const d = p.pieceData;
    addToGrid(d, d.x, d.y);
  });
}

function startTimer() {
  timerStart = Date.now();
  timerInterval = setInterval(updateTimer, 10);
}

function updateTimer() {
  const el = Date.now() - timerStart;
  const m = Math.floor(el / 60000), s = Math.floor((el % 60000) / 1000), ms = el % 1000;
  document.getElementById('timer').querySelector('span').textContent = 
    `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${String(ms).padStart(3,'0')}`;
}

function winGame(mainPiece) {
  gameWon = true;
  clearInterval(timerInterval);
  document.getElementById('timer').classList.add('flashing');
  
  const exitY = ROWS * CELL + 20;
  
  // Slide out just past the exit
  const escapeAnim = () => {
    mainPiece.y += 4;
    if (mainPiece.y < exitY) {
      requestAnimationFrame(escapeAnim);
    } else {
      // Once exited, smile and spin!
      mainPiece.y = exitY;
      
      if (mainPiece.mouth) {
        mainPiece.mouth.clear();
        mainPiece.mouth.lineStyle(4, 0x000000);
        mainPiece.mouth.arc(0, 8, 18, 0, Math.PI);
      }
      
      // Spin animation
      let spinProgress = 0;
      const spin = () => {
        spinProgress += 0.08;
        mainPiece.rotation = spinProgress * Math.PI * 2;
        if (spinProgress < 2) {
          requestAnimationFrame(spin);
        } else {
          mainPiece.rotation = 0;
          startGlow();
        }
      };
      spin();
      
      for (let i = 0; i < 120; i++) setTimeout(() => createConfetti(), i * 15);
    }
  };
  escapeAnim();
  
  // Set pivot for rotation
  const w = mainPiece.pieceData.w * CELL - 6;
  const h = mainPiece.pieceData.h * CELL - 6;
  mainPiece.pivot.set(w / 2 + 3, h / 2 + 3);
  mainPiece.x += w / 2 + 3;
  mainPiece.y += h / 2 + 3;
  
  function startGlow() {
    let glowPhase = 0;
    const glow = () => {
      if (!gameWon) return;
      glowPhase += 0.12;
      mainPiece.scale.set(1 + Math.sin(glowPhase) * 0.06);
      mainPiece.alpha = 0.85 + Math.sin(glowPhase) * 0.15;
      requestAnimationFrame(glow);
    };
    glow();
  }
}

function createConfetti() {
  const conf = new PIXI.Graphics();
  const color = [0xff6b6b, 0x4ecdc4, 0xffe66d, 0x95e1d3, 0xf38181, 0xaa96da, 0xffd700][Math.floor(Math.random() * 7)];
  conf.beginFill(color);
  conf.drawRect(0, 0, 10, 10);
  conf.endFill();
  conf.x = Math.random() * app.screen.width;
  conf.y = -20;
  conf.vx = (Math.random() - 0.5) * 10;
  conf.vy = Math.random() * 4 + 3;
  conf.rotation = Math.random() * Math.PI * 2;
  conf.vr = (Math.random() - 0.5) * 0.3;
  confettiContainer.addChild(conf);
  
  const fall = () => {
    conf.x += conf.vx;
    conf.y += conf.vy;
    conf.vy += 0.15;
    conf.rotation += conf.vr;
    if (conf.y < app.screen.height + 50) requestAnimationFrame(fall);
    else confettiContainer.removeChild(conf);
  };
  fall();
}

function resetGame() {
  gameWon = false;
  moves = 0;
  timerStart = null;
  clearInterval(timerInterval);
  
  document.getElementById('moves').textContent = '0';
  document.getElementById('timer').querySelector('span').textContent = '00:00.000';
  document.getElementById('timer').classList.remove('flashing');
  document.getElementById('reset-btn').classList.remove('visible');
  
  piecesContainer.removeChildren();
  confettiContainer.removeChildren();
  pieces = [];
  
  initialPieces.forEach(data => {
    const piece = createPiece(JSON.parse(JSON.stringify(data)));
    pieces.push(piece);
    piecesContainer.addChild(piece);
  });
  
  buildGrid();
}

init();
  </script>
</body>
</html>